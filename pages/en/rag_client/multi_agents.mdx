---
title: "Module Reuse"
icon: "book-copy"
---

In many practical scenarios, you may want to use multiple different Retriever or Generation modules in the same Pipeline to perform different logical tasks, such as hybrid retrieval or multi-agent systems.
In fact, this only requires setting different parameters for the same module.

For this reason, UltraRAG provides a simple and flexible mechanism â€”
By configuring different aliases for the same Server module, module reuse and independent calling can be achieved.

## Usage Example

### Step 1: Configure Alias Server

In `pipeline.yaml`, you can define multiple aliases for the same path under the `servers` field:

```yaml examples/hybrid_search.yaml icon="/images/yaml.svg" highlight="4,5"
# MCP Server
servers:
  benchmark: servers/benchmark
  dense: servers/retriever
  bm25: servers/retriever
  custom: servers/custom

# MCP Client Pipeline
pipeline:
- benchmark.get_data
- dense.retriever_init
- bm25.retriever_init
- dense.retriever_search:
    output:
      ret_psg: dense_psg
- bm25.bm25_search:
    output:
      ret_psg: sparse_psg
- custom.merge_passages:
    input:
      ret_psg: dense_psg
      temp_psg: sparse_psg
```

In this example, both dense and bm25 point to the same module path servers/retriever, but will be built and called as two independent Server instances.

### Step 2: Call Separately in Pipeline

In the Pipeline definition section, you can use their aliases just like calling different modules:

```yaml examples/hybrid_search.yaml icon="/images/yaml.svg" highlight="11-18"
# MCP Server
servers:
  benchmark: servers/benchmark
  dense: servers/retriever
  bm25: servers/retriever
  custom: servers/custom

# MCP Client Pipeline
pipeline:
- benchmark.get_data
- dense.retriever_init
- bm25.retriever_init
- dense.retriever_search:
    output:
      ret_psg: dense_psg
- bm25.bm25_search:
    output:
      ret_psg: sparse_psg
- custom.merge_passages:
    input:
      ret_psg: dense_psg
      temp_psg: sparse_psg
```

In this way, UltraRAG automatically distinguishes these two instances at runtime:
Each alias corresponds to independent parameter files, runtime context, and cache space, thereby achieving multi-module parallel and non-interfering calls.
